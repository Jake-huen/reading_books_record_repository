# 모두의 리눅스

# 1. 리눅스 커널

커널 : 운영체제에서 하드웨어를 제어하는 소프트웨어를 의미.

리눅스 커널 + 명령어 + 애플리케이션 → 넓은 의미의 리눅스 = 리눅스 배포판

리눅스 배포판 종류

1. 레드햇(RedHat) 계열 : Red Hat Enterprise Linux, CentOS, Fedora
2. 데비안(Debian) 계열 : Debian GNU/Linux, Ubuntu

## 리눅스 설치

: 가상화 소프트웨어 위에 리눅스 설치하는 것이 좋다

가상화 소프트웨어를 돌리는 OS를 호스트 OS, 가상화 소프트웨어에 의해 만들어진 가상의 OS를 게스트 OS라고 한다. 

가상화 소프트웨어의 종류 → 오라클이 제공하는 오라클 VM 버추어박스

설치

1. 오라클 VM Virtual Box 설치
2. Ubuntu 이미지 파일 다운로드
3. Virtual Box로 가상 머신 만들기
4. 가상머신에 Ubuntu 설치

**Ubuntu 이미지 파일(ISO 파일) → ISO파일이란 CD나 DVD 등 디스크를 파일로 만든 것으로 이러한 디스크 이미지 파일을 사용해서 물리적 디스크 없이 운영 체제를 설치하는 것이 가능하다.

**주의점 : 가상 머신의 창을 클릭하면 가상 머신의 OS에 마우스와 키보드의 제어권이 넘어가서 윈도우에서는 오른쪽 Ctrl, Mac에서는 왼쪽 Command를 누르면 다시 제어권을 가져올 수 있다. 

## GUI보다 CLI를 사용하는 이유

1. 높은 작업 효율 : 만약 a로 시작하는 모든 파일을 선택하려면 GUI 환경에서는 하나하나씩 살펴봐야 하지만, CLI에서는 `ls a*` 로 모두 확인할 수 있다.
2. GUI의 작업 순서를 암기하는 것은 무의미 : GUI는 비교적 자주 변하기 때문에 쓸모없는 지식이 될 수 있다.
3. 프로그램 간 연동 : 리눅스에서는 작은 프로그램들을 서로 연결해 좀 더 크고 복잡한 동작을 실행한다. 대표적으로 프로그램의 입출력을 주고 받을 수 있는 `파이프(|)` 기능이 있다. 
`grep “abc” sample.txt | sort` → grep과 sort라는 명령어를 연결해서 sample.txt에서 abc라는 문자열을 검색한 뒤, 그 결과를 정렬하고 출력하라고 지시하고 있다. 
GUI에서는 이와 같은 프로그램 간의 입출력 연동이 어렵다. 따라서 CLI를 사용하면 GUI보다 풍부하고 강력한 기능을 구사할 수 있다. 
4. 처리 자동화 : CLI에서는 실행할 명령어들을 파일에 기록해 놓고 일괄로 실행하는 것이 가능하다. 

## 로그아웃 : `exit`

## 셧다운

컴퓨터의 전원을 끄려고 OS를 완전히 정지시키는 것을 셧다운이라고 한다. 컴퓨터 전원을 끄기 전에는 반드시 운영 체제를 정상적으로 종료하는 것이 좋다. 

리눅스를 셧다운 하려면 `shutdown 명령어` 를 사용한다. 이 명령어를 실행하기 위해서는 슈퍼 사용자(root user)로 전환해야 한다.

`sudo su -`

슈퍼 사용자가 되면 프롬프트의 기호가 `$` 에서 `#` 으로 바뀐다. 이 상태에서 `shutdown -h now` 를 입력하면 된다. `-h` 옵션은 전원을 끄는 것을 의미한다. `-r` 옵션을 주면 재부팅한다.

`shutdown -r now` : 재부팅

** 이 때 에러가 날수도 있다. 그 이유는 명령어를 찾는 위치가 저장된 환경변수 PATH에 shutdown 명령어가 있는 /sbin 디렉터리가 등록되어 있지 않기 때문이다. 따라서 전체 경로를 입력하거나 PATH에 /sbin 디렉터리를 등록하면 된다.

`/sbin/shutdown -h now`

프롬프트를 확인하면 다음과 같다. 여기서 @앞은 사용자이름이고, @뒤에는 호스트 이름을 의미한다.

![Untitled](%E1%84%86%E1%85%A9%E1%84%83%E1%85%AE%E1%84%8B%E1%85%B4%20%E1%84%85%E1%85%B5%E1%84%82%E1%85%AE%E1%86%A8%E1%84%89%E1%85%B3%20f68a3f1d2a2848baaeda9e65a5fe96e9/Untitled.png)

리눅스 시스템에서 사용자 이름과 호스트 이름은 각각 서로 다른 개념이다.

1. **사용자 이름 (User Name):**
    - 사용자 이름은 시스템에 로그인하는 사용자를 식별하는 데 사용되는 고유한 식별자. 일반적으로 사용자 이름은 알파벳, 숫자 및 특정 기호로 구성되며 대소문자를 구분한다.
    - 사용자 이름은 사용자 계정을 생성할 때 설정되며, 사용자가 시스템에 로그인할 때 입력해야 하는 정보 중 하나이다.
2. **호스트 이름 (Host Name):**
    - 호스트 이름은 네트워크 상에서 시스템을 식별하는 데 사용되는 이름이다. 이는 로컬 네트워크나 인터넷에서 시스템을 고유하게 식별하기 위한 것이다.
    - 호스트 이름은 주로 **`/etc/hostname`** 파일이나 **`hostname`** 명령어를 통해 설정된다. 이는 시스템이 네트워크에서 인식되는 이름이다.

일반적으로, 리눅스 시스템에서 사용자 이름은 로그인 및 사용자 관리를 위한 것이며, 호스트 이름은 네트워크 식별을 위한 것이다. 사용자 이름은 로그인할 때 필요하고 사용자 간에 구분하기 위해 사용되며, 호스트 이름은 네트워크에서 시스템을 식별하는 데 사용된다.

# 2. 셸

## 셸의 역할과 리눅스 커널

만약 리눅스에서 `date` 나 `echo` 같은 명령어를 실행하면 리눅스 내부에서는 어떤 일이 생길까?

1. 키보드로 입력한 `date` 문자열을 받아들인다.
2. `date` 명령어를 찾는다.
3. 발견한 명령어를 실행한다.
4. 실행한 결과로 얻은 문자열이 화면에 표시된다.

**이중에서 3번은 리눅스의 본체인 커널이 실행하기 된다.** 커널은 운영 체제의 중심에서 CPU나 메모리 같은 하드웨어를 관리하면서 명령어를 실행하고 프로세스를 관리한다. 

사용자는 `date` 를 입력하였지만 엄밀히 말하면 사용자는 직접 리눅스 커널을 조작한 것은 아니다.

리눅스에서는 사용자가 커널을 직접 조작할 수 없게 되어 있기 때문에 둘 사이에서 명령어를 받아들이고 커널의 실행 결과를 출력하는 소프트웨어가 필요하다. 이 역할을 수행하는 소프트웨어가 셸이다. 

**즉, 셸은 커널의 인터페이스에 해당한다**

위의 과정을 다시 살펴보면 셸은 date 명령어를 찾아서 리눅스 커널에게 실행을 의뢰한다. 리눅스 커널이 명령을 실행하면 셸은 그 결과를 전달 받아 사용자의 화면에 출력한다. 

이처럼 셸은 리눅스 커널을 감싸는 역할을 담당한다. 셸은 사용자의 의뢰를 받아서 커널에 전달하므로 메신저 혹은 비서라고도 볼 수도 있다. 

리눅스를 다룰 때는 기본적으로 셸을 이용해야 한다. 

### 왜 커널과 셸은 나누어져 있을까

나누어져서 장점이 있기 때문

- 커널을 바꾸지 않고 셸만 바꿀 수 있다.
- 리눅스 외 OS를 사용할 때도 셸만 이식하면 똑같이 사용할 수 있다
- 셸을 사용할 때 에러가 발생하거나 부하가 발생해도 본체인 리눅스 커널에 미치는 영향을 최소한으로 줄일 수 있다

‘한 프로그램에 너무 많은 기능을 넣지 않는다’ 는 것이 리눅스의 기본 철학이다. 적절히 분리하는 것이 좋은 설계 철학이다. 

리눅스에 로그인하면 셸이 입력을 대기하는데, 이 이유는 사용자가 로그인할 때 리눅스가 자동으로 셸을 시작하기 때문이다. 이렇게 로그인 후 처음으로 시작되는 셸을 로그인셸이라고 부른다. 

### 대화형 조각과 셸 스크립트

명령어를 직접 입력하고 결과를 확인하는 조작 방식을 **대화형(인터렉티브) 방식**이라고 한다.

이에 반해 실행하고 싶은 명령어들을 미리 파일에 기록하고 그 파일을 셸에 넘겨주는 방식으로 명령을 수행하는 방식도 있다. 이렇게 **일련의 명령어 흐름을 기술한 파일을 셸 스크립트** 라고 한다. 

셸 스크립트는 ‘작은 프로그램을 조합해 복잡한 처리를 수행한다’ 라는 리눅스의 철학이 담긴 강력한 도구이다. 

### 셸 종류

1. sh
2. csh
3. bash : 대화형 조작에 필요한 기능을 갖추고 있어 많은 리눅스에서 기본 로그인 셸로 사용하고 있다.
4. tsch : C셸 계열의 셸
5. zsh : 비교적 최근에 개발된 셸로 bash와 tcsh의 기능에 독자적인 기능이 추가되었다. 

## 터미널이란

터미널이란 컴퓨터의 입출력만을 담당하는 전용 하드웨어를 의미한다. 

터미널이란 컴퓨터의 입출력만을 담당하는 전용 하드웨어를 말한다. 입력 장치인 키보드와 출력 장치인 모니터로 구성된다. 현재 리눅스를 다룰 때 하드웨어 터미널을 사용하는 경우는 거의 없다. 대신에 소프트웨어로 구현한 터미널 에뮬레이터가 사용된다. 터미널 에뮬레이터는 리눅스, 윈도, 맥 등에서 애플리케이션으로 동작한다. 

터미널 에뮬레이터는 물리적인 터미널처럼 입출력을 위한 인터페이스를 제공한다. 운영체제별로 터미널 에뮬레이터는 다양하다.

Windows - PuTTY, Tera Term

macOS - terminal, iTerm2

Linux - GNOME Terminal, Konsole

### 터미널과 셸

터미널과 셸은 완전히 다른 소프트웨어이다. 예를 들어 윈도에서 리눅스로 원격 로그인하면 터미널 에뮬레이터는 윈도 머신에서 돌아가며 셸은 리눅스 머신에서 돌아간다. 

터미널 에뮬레이터는 입출력 화면을 제공만 하는 소프트웨어이다. 리눅스 머신에서 돌아가는 셸의 입출력을 제공하는 소프트웨어가 바로 터미널 에뮬레이터이다.

# 3. 셸을 능숙하게 다루는 방법

## 커맨드 라인 편집

### 커서 이동

Ctrl을 누를채 b나 f를 눌러야 한다.

`Ctrl + b` : 커서를 뒤로 이동

`Ctrl + f` : 커서를 앞으로 이동

### 커서를 처음과 끝으로 이동

`Ctrl + a` : 커서를 한번에 맨 앞으로 이동할 수 있다.

`Ctrl + e` : 커서를 맨 뒤로 보낼 수 있다. 

### 단어 단위로 커서 이동

`Esc` 나 `Alt` 를 `Meta` 에 해당한다. 여기서는 누르고 뗀 뒤에 조작하면 된다.

`Meta + b` : 한 단어 뒤로 이동

`Meta + f` : 한 단어 앞으로 이동

### 문자 삭제

`backspace` 또는 `Ctrl + h` : 커서 위치 기준으로 뒤에 있는 한 문자를 삭제함

`Delete` 또는 `Ctrl + d` : 커서 위치의 한 문자를 삭제함

`Ctrl + w` : 커서 뒤에 공백이 나오기 전까지 있는 문자들을 삭제함(한 단어를 지울 때 사용)

커맨드 라인에 아무것도 입력하지 않은 상태에서 `Ctrl+d` 를 입력하면 bash가 로그아웃된다.

### 자르기와 붙여넣기

`Ctrl + k` : 커서의 위치에서 끝까지 삭제

`Ctrl + u` : 커서의 위치에서 커맨드 라인의 첫 문자까지 삭제

`Ctrl + y` : 마지막으로 지운 내용을 삽입

Ctrl+k 나 Ctrl+u 는 단순히 삭제가 아니라 자르기에 해당하는 단축키이다. (paste, yank)

## 셸을 사용하면서 만날 수 있는 문제

### 키보드 입력이 안되는 경우

갑자기 키보드 입력이 화면에 표시되지 않을 때에는 화면에 표시하는 것을 잠그는 `Ctrl+s` 를 눌렀을 가능성이 있다. `Ctrl+q` 를 누르면 화면 표시 잠금이 해제된다.

### 실행한 명령이 종료하지 않아 프롬프트가 뜨지 않는 경우

리눅스의 일부 명령은 실행한 뒤 명시적으로 종료하지 않으면 계속 실행 상태에 있다. 이러한 명령을 실행하면 프롬프트로 돌아오지 않기 때문에 직접 종료해야 한다. 실행중인 명령을 강제 종료하려면 `Ctrl+c` 를 눌러야 한다.

### 프롬프트 문자가 깨지는 경우

이미지 파일 같은 바이너리 파일을 셸에서 출력하면 프롬프트이 문자가 깨지는 경우가 있다. 이때에는 화면을 지우는 `Ctrl+l` 을 입력한다. 

## 자동완성 기능

`tab` 으로 자동완성할 수 있다. 

## 명령 이력

`ctrl + p` : 바로 전 명령으로 이동

`ctrl + n` : 다음 명령으로 이동

`ctrl + r` : 이력을 검색

→ 문자를 입력해서 이력을 검색한다.

# 4. 파일과 디렉토리

리눅스는 파일로 구성된다. 또한, 리눅스에서는 사용자의 데이터뿐만 아니라 시스템을 구성하는 장치조차도 파일로 다룬다. 예를 들어 하드 디스크, 키보드, 프린터 같은 입출력 장치를 전부 파일로 다룬다. 심지어 리눅스 커널도 파일이고 시스템 설정도 파일에 기록된다. **모든 것을 파일로 다룬다**

## 리눅스의 디렉터리 구조

### **디렉터리란**

파일의 개수가 많아지면 종류별로 분류하는 것이 좋다. 여러 개의 파일을 담아서 정리할 수 있는 것이 디렉터리이다. 윈도나 맥의 폴더 개념과 동일하다. 

루트 디렉터리 - bin, dev, etc, home, sbin, tmp, usr, var … 

/ 디렉터리 → 루트 디렉터리

모든 파일과 디렉터리의 부모를 찾아 올라가면 루트 디렉터리에 도달하게 된다. 루트 디렉터리 아래에 디렉터리와 파일이 있는 계층 구조를 트리 혹은 디렉터리 트리라고 한다. 

### PATH

특정 파일의 위치를 나타내는 것을 디렉터리 사이에 슬래시를 넣어 표기한다. 그리고 이를 해당 파일에 대한 경로라고 한다. 

경로에서 디렉터리를 구분하기 위해 사용하는 문자로 리눅스는 / 를 사용하고, 윈도는 ₩를 사용한다.

### 윈도와의 차이

윈도도 리눅스와 비슷한 트리 구조를 가지지만, 윈도에서는 물리 디스크가 2개 있다면 디렉터리 트리도 2개이다. 

하지만 **리눅스에서는 언제나 시스템 전체에 단 하나의 트리만 가지게 된다**

리눅스에서는 디스크가 여러 개 있을 때 루트 디렉터리의 어딘가에 해당 디스크의 디렉터리가 연결된다. 이렇게 디스크의 디렉터리를 연결하는 것을 마운트라 한다. 

### 각 디렉터리의 역할

디렉터리의 구조는 배포판마다 조금씩 다르다. 대부분의 배포판에서 동일하게 볼 수 있는 대표적인 디렉터리만 소개하겠다.

리눅스의 디렉터리 구조는 FHS라는 표준 사양을 따른다. 

### /bin

: 일반 사용자 및 관리자가 사용하는 명령어의 실행 파일이 배치되어 있는 디렉터리. 특히 시스템과 관련된 중요도가 높은 명령어를 포함함

### /dev

: 디바이스 파일이 배치되어 있는 디렉터리. 디바이스 파일이란 디스크나 키보드 등 하드웨어를 다루기 위한 특수 파일.

### /etc

: 리눅스에서 돌아가는 다양한 애플리케이션의 설정파일이 배치된다. 애플리케이션뿐만 아니라 리눅스 자체의 설정 파일도 이곳에 있다. 따라서 리눅스를 운영하고 관리할 때 중요한 디렉터리.

### /home

: 사용자별로 할당되는 홈 디렉터리가 배치되는 디렉터리. 홈 디렉터리란 사용자별로 할당되는 개인용 디렉터리를 의미한다. 사용자 이름이 디렉터리 이름으로 사용된다. 예를 들어 사용자 이름이 jake라면 홈 디렉터리는 `/home/jake` 가 된다. 사용자는 홈 디렉터리 안에서 자유롭게 파일이나 디렉터리를 작성해 작업할 수 있다.

### /sbin

: `/bin` 과 비슷하게 실행 파일을 포함하는 디렉터리. 이 디렉터리에는 관리자용 명령어가 포함되어 있다.
 (ex> `shutdown`)

### /tmp

: 임시 파일이 들어 있는 디렉터리. 애플리케이션 실행 중 임시로 작업 결과를 파일로 보존할 때 보통 이 디렉터리에 저장한다. 정기적으로 이 디렉터리 안의 파일을 삭제하도록 설정된 배포판도 있으므로 중요한 파일을 보관하면 안된다. 

### /usr

: 설치한 애플리케이션의 실행 파일, 문서, 라이브러리 등이 이 디렉터리에 포함된다. `/usr` 아래에는 bin, sbin, etc 등이 있어서 루트 디렉터리와 구조가 비슷하다.

### /var

: 변화하는 데이터를 저장하기 위한 디렉터리. 애플리케이션 실행 중에 만들어진 데이터나 로그, 메일 등이 저장된다. `/var` 에는 많은 파일이 기록되므로 용량이 부족해질수도 있으니 시스템을 관리할 때 주의해야 한다.

## 현재 디렉터리와 pwd

현재 위치한 디렉터리를 현재 디렉터리, 영어로 current directory 혹은 working directory 라고 한다. 

현재 디렉터리는 `pwd` 명령어로 확인한다.

## 절대 경로와 상대경로

### 절대 경로

루트 디렉터리부터 해당 파일에 이르는 경로를 표시하는 것.

### 상대 경로

현재 디렉터리의 위치를 기준으로 표기하는 경로를 의미

`.` 은 현재 디렉토리를 뜻함. `..` 은 부모 디렉터리를 의미함.

## 디렉터리 이동

`cd` : 현재 디렉터리 변경

`ls` : 디렉터리 안의 파일을 출력

`cd ~` : 홈 디렉터리로 이동

### *와 ?

`*` : 임의의 문자열

`?` : 임의의 한 문자

### ls 명령어의 옵션

하이픈(-)으로 시작하는 옵션을 지정할 수 있다. 

`-l` 옵션으로 표시되는 정보

drwr-xr-x. 20 root root 4096 9월 26:00 var

파일 타입, 파일모드(d디렉터리, l 심볼릭 링크), 링크 수, 소유자, 소유 그룹, 크기, 타임스탬프, 파일 이름또는 디렉터리 이름

`-a` : 숨겨진 파일도 함께 출력

`-F` : 파일 이름 뒤에 파일의 종류를 의미하는 기호를 추가해 출력

(보통 파일 : 표시되지 않음, 디렉터리 : / , 실행 가능 파일 : * , 심볼릭 링크 : @)

### 명령어의 옵션

옵션의 인자를 지정 : ls 명령어의 -w 옵션은 지정한 값에 맞게 문자 간격을 맞춰 출력함.

롱 옵션 : `--` 처럼 하이픈 두 개로 시작하는 옵션 형식도 있다. 

`ls --quote-name` 

인자의 롱 옵션은 옵션과 인자 사이에 공백을 주거나 `=` 기호를 사용한다. 

아래 4가지는 모두 동일하게 동작한다. 

`ls --width=30`

`ls -w 30`

`ls -w30`

`ls --width 30`

# 5. 파일 조작의 기본

## mkdir 명령어 : 디렉터리 만들기

### 중첩된 디렉터리 한 번에 만들기

`mkdir -p report/2021/05` : 이렇게 하면 report부터 시작해서 2021과 05라는 디렉터리를 한 번에 만들 수 있다.

## touch 명령어 : 파일 만들기

`touch <생성할 파일1> <생성할 파일2>` 

touch 명령어는 내용이 없는 빈 파일을 생성한다. 

## rm과 rmdir : 파일과 디렉터리 삭제하기

`rm [옵션] <삭제할 파일1> <삭제할 파일2>`

### 여러 파일 삭제하기

`rm file1 file2 file3`

### 디렉터리 삭제하기

rm 명령어로 디렉터리를 지우려면 재귀적으로 디렉터리 트리를 삭제하는 옵션인 `-r` 을 지정해야 한다.

이때 대상이 되는 디렉터리와 그 안의 파일을 전부 지우므로 주의해야 한다. 

`rm -r dir1`

### 삭제할 때 주의할 점

윈도나 맥에서는 휴지통이 있어서 복구할 수 있지만 리눅스에서는 곧바로 지워진다. 그래서 리눅스에서는 실행할 때 `-i` 옵션을 붙이면 확인 메시지가 출력된다.

### 빈 디렉터리 삭제하기

`rm` 명령어와 비슷한 명령어로 `rmdir` 이라는 명령어가 있다. 이 명령어는 빈 디렉터리를 삭제하는 명령어이다.

`rmdir <디렉터리 이름>`

`rmdir` 명령어는 대상 디렉터리가 빈 디렉터리가 아니면 에러를 출력한다. 

`rmdir` 명령어를 이용하면 디렉터리 안에 숨겨진 파일을 실수로 지우는 것을 방지할 수 있다.

## cat 명령어 : 파일 내용 출력하기

`cat [옵션] <파일이름>`

### 여러 파일 출력하기

cat 명령어의 인자로 여러 파일을 지정하면 순차적으로 그 내용이 출력된다.

### 행 번호 출력하기

cat 명령어를 실행할 때 옵션으로 `-n` 을 지정하면 행 번호가 함께 출력된다. 

`cat -n /etc/crontab`

### 파일을 지정하지 않은 경우

파일을 지정하지 않고 cat 명령어를 실행하면 그 다음 아무 문자나 입력했을 때 입력한 내용이 그대로 출력된다.

즉, cat 명령어는 인자로 파일이 지정되지 않으면 키보드 입력을 그대로 화면에 출력하는 동작을 수행한다. 

이 상태에서 cat 명령어를 종료하려면 `Ctrl + d` 를 입력하면 된다.

## less 명령어 : 스크롤 표시하기

cat 명령어로 내용이 긴 파일을 출력하면 화면이 스크롤되면서 전부 출력된다. 따라서 파일의 첫 부분부터 필요한 만큼 읽고 싶다면 cat 명령어가 아니라 less 명령어를 사용하는 것이 좋다. 

`less [옵션] <파일 이름>`

less는 지정한 파일을 보기 좋게 화면 단위로 출력하며 위아래로 스크롤하며 파일을 볼 수 있게 해준다. 

`less /etc/bash.bashrc`

less명령어를 실행하면 파일의 첫 행부터 화면에 담을 수 있는 부분까지 출력된다. 

less 명령어로 파일을 볼 때 사용하는 단축키는 다음과 같다.

`Space` , `f`, `Ctrl+v` : 한 화면 아래로 스크롤

`b` , `Meta + v` : 한 화면 위로 스크롤

`j` , `Ctrl + n` , `Enter` : 한 행 아래로 스크롤

`k` , `Ctrl + p` : 한 행 위로 스크롤

`q` : less 명령어 종료

여기서 Space, b, q 만 기억하면 된다.

### 파일 내 검색

less 명령어로 열려 있는 파일에서 문자열을 검색할 수 있다. 이때 `/` 를 입력하여 문자열을 검색한다. 

`/문자열` : 문자열을 아래 방향으로 검색

`?문자열` : 문자열을 위 방향으로 검색

`n` : 다음 검색 결과로 이동

`N` : 이전 검색 결과로 이동

## cp 명령어 : 파일과 디렉터리 복사하기

`cp [옵션] <복사할 파일> .. <복사할 위치>`

`cp file1 file2`

복사할 위치에 디렉터리를 지정하면 해당 디렉터리 안에 복사된다. 

### 복사와 덮어쓰기

cp로 복사할 때 이미 같은 이름의 파일이 있으면 덮어쓴다. 

따라서, 복사하기 전에 같은 이름의 파일이 있는지, 덮어써도 되는지를 확인해야 한다. cp 명령어가 덮어쓰기 전에 확인하도록 하려면 -i 옵션을 사용해야 한다. 그러면 cp 명령어가 덮어 쓰기 전에 진행 여부를 확인한다. 이때 y혹은 Y를 입력하면 덮어쓰게 된다.

`cp -i file1 file2`

### 디렉터리 복사하기

cp 명령어로 디렉터리를 복사하려고 하면 에러가 발생한다. 

cp 명령어로 디렉터리를 복사하려면 재귀적으로 복사하도록 `-r` 옵션을 지정해야 한다.

`cp -r dir2 dir3`

이때 dir3가 없으면 dir2 내용이 모두 복사되어 dir3가 만들어진다. 

dir3가 이미 있는 경우라면 dir3 밑에 dir2라는 이름으로 복사된다. 

## mv 명령어 : 파일 이동하기

파일 위치를 옮길 때는 mv 명령어를 사용한다. 

mv도 cp와 비슷하게 이동할 위치로 파일을 지정했는지, 디렉터리를 지정했는지에 따라 다르게 동작한다. 

`mv [옵션] <이동할 파일> ... <이동할 위치>`

이동할 파일과 이동할 위치에 전부 파일을 지정하면 결과적으로 파일 이름이 바뀌게 된다. 

**파일 이름 바꾸기**

`mv file1 file2` : file1 파일을 file2라는 이름으로 바꾸기

**특정 파일을 특정 디렉터리 안으로 옮기기**

`mv file1 dir1` : file1을 dir1 디렉터리 안으로 옮기기

**여러 파일을 한꺼번에 특정 디렉터리로 옮기기**

`mv file1 file2 file3 dir1` : dir1 디렉터리로 파일 세 개 옮기기

이동할 위치에 같은 이름의 파일이 있으면 덮어쓰는 것도 `cp` 와 유사하다. i 옵션을 지정하면 덮어쓰기 전에 정말로 덮어쓸지 확인해 준다. 

`mv -i file1 file2` 

**디렉터리 이동하기**

디렉터리를 이동할 떄는 cp에서처럼 r옵션을 지정하지 않아도 디렉터리 안의 모든 파일과 디렉터리를 전부 옮긴다.

`mv dir1 dir2` : dir1 디렉터리를 dir2 디렉터리 안으로 이동

## ln 명령어 : 링크 만들기

`ln [옵션] <링크할 파일> <링크 이름>`

### 링크란?

리눅스의 파일 시스템에서는 파일에 별명을 붙이는 것이 가능하다. 이를 링크라고 부르며 별명을 붙이는 것을 ‘링크를 생성한다’ 라고 한다.

링크에는 하드 링크와 심볼릭 링크 두 종류가 있다. 보통 심볼릭 링크가 많이 사용되며 하드 링크가 필요한 경우는 많지 않다.

### 심볼릭 링크

`ln` 명령어를 사용할 때, `-s` 옵션을 붙이면 심볼릭 링크가 만들어진다. 

`/etc/crontab` 을 복사한 file1에 대해 file2라는 심볼릭 링크를 만드는 예시이다.

`cp /etc/crontab file1`

`ln -s file1 file2`

ls 명령어를 실행할 때 `-l` 옵션을 지정하면 심볼릭 링크 여부를 확인할 수 있다. 어떤 파일에 연결되었는지 화살표(→)로 표시된다.

심볼릭 링크 파일에 접근하면 링크로 연결된 파일에 접근할 수 있다. 

### 심볼릭 링크 삭제하기

심볼릭 링크는 `rm` 명령어로 지울 수 있다. 이때 원본에는 아무런 영향을 주지 않는다. 

심볼릭 링크를 지우지 않은 채 원본 파일을 지울 수도 있다. 그러면 심볼릭 링크가 깨진 상태가 된다. 

### 링크가 유용한 경우

어떤 상황에서 링크를 사용하면 좋을까?

1. 긴 경로명을 짧게

`ln -s local/work/code/project/source source`

`cd source`

1. 여러 버전의 프로그램이 있는 경우

프로그램을 설치할 때 디렉터리 이름에 버전 정보를 붙여 여러 버전의 소프트웨어를 배치하는 경우가 있다. 

# 6. 파일 검색 및 명령어 사용법

## 파일을 찾는 방법

파일을 찾는 명령어로는 `find` 와 `locate` 가 있다.

### find 명령어 : 디렉터리 트리에서 파일 찾기

find는 이름 그대로 파일을 찾는 명령어이다. 

`find <검색할 디렉터리> <검색 조건> <액션>`

인자로 지정한 검색할 디렉터리를 기점으로 검색 조건을 만족하는 파일을 찾아서 액션을 실행한다. 여기서 검색 조건에 아무런 조건도 없으면 지정한 디렉터리 안의 모든 파일과 디렉터리를 대상으로 액션이 실행된다. 

`find . -name file-1.txt -print`

액션에 아무런 인자도 지정하지 않으면 `-print` 가 기본적으로 사용된다.

find 명령어로 지정할 수 있는 검색 조건은 여러 가지가 있는데 자주 사용되는 걸로는

 `-name` , `-iname` , `-type` 이 있다.

### 이름으로 찾기(`-name` , `-iname` )

파일 이름으로 검색한다. `-name` 은 대소문자를 구분하지만, `-iname` 은 대소문자를 구별하지 않는다.

파일 이름에는 와일드카드로 *나 ?가 사용될 수 있다. 

`-name` 으로 이름을 지정할 때나 *나 ?를 사용한다면 반드시 **작은 따옴표로 감싸줘야 한다.**

### 파일 형식으로 찾기(`-type`)

`type <파일 형식>` 을 지정하면 파일의 형식으로 검색한다. 지정할 수 있는 파일 형식이 많지만 자주 사용되는 세가지가 있다.

`-type f` : 보통 파일

`-type d` : 디렉터리

`-type l` : 심볼릭 링크

예시 > `find . -type d -print`

### 검색 조건 여러 개 지정하기 (`-a`)

find 명령어를 사용할 때 a(AND)를 사용하여 검색 조건을 여러 개 지정하면 해당 조건에 모두 일치하는 파일을 찾을 수 있다.

`find . -type f -a -name '*.txt' -print`

검색조건1 : 일반파일을 찾아라, 검색조건2 : 파일 이름이 .txt로 끝남

또한 `-a` 는 생략할 수 있다. 

### locate 명령어 : 데이터베이스에서 파일 찾기

locate는 경로의 일부를 지정하여 파일을 찾을 때 사용하는 명령어이다. 이때 전용 데이터베이스에서 검색하므로 그 자리에서 디스크를 스캔해서 파일을 찾는 find보다 훨씬 빠르다.

1. locate 명령어 설치하기

우분투에서는 `apt-get` 을 이용해서 설치하고 CentOS에서는 `yum` 을 이용하여 설치한다.

`sudo apt-get install mlocate`

1. 파일 경로 목록을 데이터베이스에 등록하기 → `updatedb` 명령어를 실행하면 데이터베이스가 만들어진다.

`sudo updatedb`

1. 파일 찾기

`locate [옵션] <검색 패턴>`

- bash라는 문자열이 포함된 경로 검색 : `locate bash`

find는 실행할 때마다 디렉터리 트리를 탐색해서 많은 파일이 저장된 디스크를 검색할 때는 시간이 오래 걸린다. 하지만 `locate` 는 사전에 만든 데이터베이스를 사용하기 때문에 검색 속도가 빠르다. 

## 명령어 사용법 확인하기

리눅스 시스템에 내장된 메뉴얼을 확인하는 것이 좋다.

### —help 옵션

`cat --help` 

대부분 사용 방법, 명령어에 대한 개요, 지정할 수 있는 옵션 목록과 그 의미 등을 포함한다. 

### man 명령어 : 메뉴얼 출력

man은 지정한 명령어의 온라인 메뉴얼을 출력하는 명령어이다. 

man은 전통적인 리눅스의 기본 메뉴얼로서 대부분의 명령어에 대해 help 옵션보다 훨씬 자세한 내용을 담고 있다. 

`man <알고 싶은 명령어>`

### 키워드로 메뉴얼 찾기

명령어의 이름을 모르는 경우에는 키워드로 메뉴얼을 검색할 수 있다. `-k` 옵션을 사용하면 된다.

`man -k <키워드>`

## 명령어 검색

### which 명령어 : 명령어의 전체 경로 표시

- cat 명령어의 경로는 `/bin/cat`

하지만 우리가 `cat` 을 사용할 때는 `/bin/cat` 이라고 하지 않고, `cat` 이라고 입력한다. 이는 **셸이 $PATH라는 환경 변수에 저장된 장소에서 명령어를 찾도록 되어 있기때문이다.**

cat 명령어를 입력하면 $PATH로 지정한 디렉터리에서 명령어를 찾는다. $PATH에 설정된 디렉터리를 패스(path)라고 한다. 패스를 설정해두면 명령어가 실제 어디에 있든 명령어의 이름만으로 실행하는 것이 가능해진다. 

명령어 파일의 실제 위치는 which 명령어를 사용해 알 수 있다. 

`which cat`

같은 이름의 파일이 여러 개 있으면 제일 먼저 발견된 것만 출력한다. 같은 이름의 파일을 전부 다 출력하려면 a 옵션을 지정해야 한다.

`which -a lsmod`

# 7. 텍스트 에디터

## 텍스트 파일과 바이너리 파일

파일은 내용에 따라 텍스트 파일과 바이너리 파일로 나뉜다. 

텍스트 파일은 이름 그대로 텍스트가 적혀진 파일이고, `cat` 이나 `less` 를 통해 텍스트 파일의 내용을 확인하는 것이 가능하다. 

바이너리 파일은 이미지나 음성 파일, 리눅스 명령어 파일을 말한다. 이들은 텍스트로 쓰인 것이 아니라서 사람이 직접 읽을 수 없다. 

리눅스에서는 설정 파일이나 스크립트 등 많은 부분에서 텍스트 파일이 사용된다. 예를 들어 지금까지 사용한 배시나 웹 서버로 많이 사용되는 아파치의 설정 파일 등이 텍스트 파일이다. 

### vim: 기본 에디터

리눅스에서 사용할 수 있는 에디터 중 유명한 것은 Vim 과 Emacs이다. 

vim을 사용하려면 `vim` 이라는 명령어를 사용해야 한다. 

vim을 종료하려면 `:q` 를 입력하면 된다.

### 파일 열기

`vim <파일 이름>`

### 파일 저장하기

`:w`

만약 파일을 편집하고 저장하지 않은 채 종료할 때, 편집한 내용을 저장하지 않고 종료하려면 `:q!` 를 사용하면 된다.

`:w <파일 이름>` : 파일 이름을 지정하여 저장

### Vim 파일 편집

Vim으로 파일을 열면 커서가 파일의 맨 첫 부분에 있다. 커서를 옮기려면 `h, j, k, l` 을 사용해야 한다.

h는 왼쪽, j는 아래, k는 오른쪽, l은 위쪽을 의미한다.

### 문자 삭제

Vim에서 문자를 지우려면 지우고 싶은 문자 위에서 `x` 를 누르면 된다. 

### 문자 입력

Vim에서 문자를 입력하려면 `i` 를 눌러야 한다. 입력이 끝났으면 `Esc` 를 누르면 된다. 

## 커서 이동

### 단어 단위로 이동

`h` 나 `l` 로는 한 문자씩 커서를 이동할 수 있다.

`w`를 사용하면 다음 단어의 첫 글자로 이동할 수 있다.

### 행의 처음이나 끝으로 이동

`o` : 행의 시작으로 이동

`$` : 행의 끝으로 이동

## 자르기, 복사하기, 붙여넣기

### 삭제

지우기 위해서는 `x` 를 누르거나 d 명령어를 사용한다. d 명령어의 경우 범위를 지정할 수 있다. 

### 붙여넣기

`p` 로 원하는 곳에 붙여 넣을 수 있다.

### 복사

`y` 를 사용한다. y도 d와 비슷하게 복사할 범위를 지정한다. 

## 검색과 치환

### 검색

파일 내의 문자열을 검색하기 위해서는 `/` 과 검색하고 싶은 문자열을 입력한 뒤 Enter를 누르면 된다. 

### 치환

`%s/<검색할 문자열>/<치환할 문자열`

`%s/day/pen/g`

# 8. 배시 설정

# [9. 퍼미션과 슈퍼 사용자](https://github.com/Jake-huen/reading_books_record_repository/blob/main/%EB%AA%A8%EB%91%90%EC%9D%98%20%EB%A6%AC%EB%88%85%EC%8A%A4/9.%ED%8D%BC%EB%AF%B8%EC%85%98%EA%B3%BC%20%EC%8A%88%ED%8D%BC%20%EC%82%AC%EC%9A%A9%EC%9E%90.md)

# ETC 1> 포트, 방화벽 확인 및 포트열기

## 1. 포트 상태 확인

### 열려있는 모든 포트 표시

`netstat -nap`

`-n` : host명으로 표시 안함

`-a` : 모든 소켓 표시

`-p` : 프로세스ID와 프로그램명 표시

### LISTEN 중인 포트 표시

`netstat -nap | grep LISTEN`

### 확인하려는 포트 번호 상태확인

`netstat -nap | grep 포트번호`

## 2. 포트 열기

리눅스 방화벽 설정 명령어인 iptables를 사용하여 포트를 오픈할 수 있다.

### 방화벽 설정 정보 확인하기

`iptables -nL`

### 특정포트 외부에서 접속할 수 있도록 열기(외부에서 접속할 수 있도록 포트 OPEN)

ex> 외부에서 들어오는 TCP 포트 12345의 연결을 받아들인다는 규칙을 1번 방화벽 규칙으로 추가한다

1. TCP 포트인 경우
`iptables -I INPUT 1 -p tcp --dport 12345 -j ACCEPT`
2. UDP 포트인 경우
`iptables -I INPUT 1 -p udp —dport 12345 -j ACCEPT`

`-I` : 새로운 규칙을 추가한다

`-p` : 패킷의 프로토콜을 명시한다

`-j` : 규칙에 해당하는 패킷을 어떻게 처리할지를 정한다

### 내부에서 외부로 나갈 수 있도록 포트 열기

`iptables -I OUTPUT 1 -p tcp --dport 9002 -j ACCEPT`

`iptables -I OUTPUT 1 -p udp --dport 9002 -j ACCEPT`

### 추가한 설정 조회

`iptables -L -v`

추가한 설정 삭제

1. 규칙 번호로 삭제 `iptables -D INPUT 1`
2. 추가한 규칙으로 삭제 `iptables -D INPUT -p tcp --dport 12345 -j ACCEPT`
3. 변경사항 저장

```jsx
service iptables save
/etc/init.d/iptables restart
```

## 방화벽 활성화&비활성화

### 방화벽 켜기

`/etc/init.d/iptables start`

### 방화벽 끄키

`/etc/init.d/iptables stop`
